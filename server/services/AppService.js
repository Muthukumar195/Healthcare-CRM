const _ = require('lodash'),
  passport = require("passport");
const useragent = require('express-useragent');
const axios = require('axios');
const { createLogger, format, transports } = require('winston');
const { combine, timestamp, label, prettyPrint } = format;
const config = require("../configs/config");
const Audit = require("../models/AuditModel");
const VideoSessionLogs = require("../models/VideoSessionLogsModel");

const authGuard = passport.authenticate(["jwt", "patientJWT"], { session: false });
const errorHandling = (err, req, res) => {
  console.log(err)
  if (!_.isEmpty(err.errors)) {
    var validationErr = {};
    _.forEach(err.errors, function (er, key) {
      validationErr[key] = er.properties.message;
    });
    res.json({ status: false, errors: validationErr, message: err._message });
  } else {
    res.json({ status: false, message: err._message });
  }
};
const sendResponse = (res, status, message = "Response Succesfully!", data = []) => {
  if (status) {
    res.json({ status, message, data });
  } else {
    res.json({ status, message });
  }

};
const session = (request) => {
  var user = request.user; 
  if(!_.isEmpty(user)){
    user.userId = user._id;
    return user;
  }else{
    return {userId: null, userRole: null}
  }
 
}; 

const log = createLogger({
  level: 'info',
  format: combine(
    // label({ label: 'right meow!' }),
    timestamp(),
    prettyPrint()
  ),
  transports: [
    new transports.Console(),
    new transports.File({ filename: 'logs/errors.log', level: 'error' }),
    new transports.File({ filename: 'logs/info.log', level: 'info' }),
  ],
  //exceptionHandlers: [
  // new transports.File({ filename: 'logs/exceptions.log' })
  //],
  //rejectionHandlers: [
  // new transports.File({ filename: 'logs/rejections.log' })
  //]
});

const auditLog = (req, action = "", isAuto = false) => { 
  var source = req.headers['user-agent'],
  ua = useragent.parse(source); 

  let logData = {
    reqUser: session(req).userId,
    action: action,
    api: req.originalUrl,
    inputParams: req.body,
    sessionId: req.body.sessionId,
    isSendInvite: req.body.isSendInvite,
    hasAudioDenied: req.body.hasAudioDenied,
    hasVideoDenied:  req.body.hasVideoDenied,
    hasNoAudioVideo: req.body.hasNoAudioVideo,
    hasVideoRendered: req.body.hasVideoRendered,
    message: req.body.message,
    browser: `${ua.browser}/${ua.version}`,
    os: ua.os,
    platForm: ua.platform,
    isDoctor: (session(req).userRole == "admin")? true : false,
    speed: req.body.speed,
    isAutoGenerated: isAuto
  }
  Audit.create(logData, (err, audit) => {
    if (err) { console.log(err) }
  });
}

const videoSessionLog = (data) => {
  // let logData = {
  //   sessionId: data.sessionId,
  //   isDoctor: data.isDoctor,
  //   hasAudioDenied: data.hasAudioDenied,
  //   hasNoAudioVideo: data.hasNoAudioVideo,
  //   hasVideoDenied: data.hasVideoDenied,
  //   browser: data.browser

  // } 
  VideoSessionLogs.create(data, (err, audit) => {
    if (err) { console.log(err) }
  });
}

const verifyReCaptcha = (req, callback)=>{  
  if(req.body.reCaptcha === undefined || req.body.reCaptcha === '' || req.body.reCaptcha === null) {
    callback({ status: false, reset: false, message: "Please select captcha" });
  } 
  var verificationUrl = "https://www.google.com/recaptcha/api/siteverify?secret=" + config.reCaptchaSecretKey + "&response=" + req.body.reCaptcha+ "&remoteip=" + req.connection.remoteAddress;
   
  axios.get(verificationUrl).then(function (response) {  
    if(response.data.success !== undefined && !response.data.success) { 
      callback({ status: false, reset: false, message: "Failed captcha verification" });
    }else{ 
      callback({ status: true, message: "Sucess" });
    } 
  })
  .catch(function (error) { 
    console.log(error);
    callback({ status: true, captchaErr: true, message: "Failed captcha verification" });
  }) 
}

const crossTxt = (txt)=>{ 
 var AtSymbol = txt.indexOf("@");
 if(AtSymbol > 0){
  var posText = txt.substr((AtSymbol/2), (AtSymbol-(AtSymbol/2)));
  var maskedTest = txt.replace(posText, "XXXX"); 
  return maskedTest;
 }else{
  return txt.replace(/[^0-5\.]+/g, 'X');
 } 
}


module.exports = { authGuard, errorHandling, sendResponse, session, log, auditLog, videoSessionLog, verifyReCaptcha, crossTxt };
